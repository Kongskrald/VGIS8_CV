%!TEX root = ../../master.tex
\chapter{Code}
\label{ap:all_code}

\begin{lstlisting}[caption={Initalisation of data and constants},language=C,label={apcode:init},tabsize=2]
#define Rcv 0x08
#define Xmit 0x20

//Filter initalisation
#define Fs 44100

#define ftFs (unsigned long long) 176400
#define etFs (unsigned long long) 352800

short fc[3][5] = {0};
short fd[3][5] = {0};

const short dbtoa[] = {16, 18, 20, 23, 25, 28, 32, 36, 40, 45, 51, 57, 64};
const short dbtog[] = {0, 2, 4, 7, 9, 12, 16, 20, 24, 29, 35, 41, 48};

//delay and reverb initalisation
#define DelayBuff  30000

#pragma DATA_SECTION(delay_buff, ".dlybff")
short  delay_buff[DelayBuff] = {0};
#pragma DATA_SECTION(delay_buff2, ".dlybff2")
short  delay_buff2[DelayBuff] = {0};

//more reverb
#define APLEN 6000
#pragma DATA_SECTION(ap_buff, ".reverb")
short ap_buff[APLEN] = {0};
#pragma DATA_SECTION(comb_lat, ".reverb")

short comb_lat[270] = {0};

#pragma DATA_SECTION(comb_dly, ".reverb")
short comb_dly[6][3310] = {0};

unsigned short dlylinesmp[] = {2205, 5733, 9261, 12789, 16317, 19845};
\end{lstlisting}

\begin{lstlisting}[caption={Implementation of generic second order filter.},language=C,label={apcode:func_filter},tabsize=2]
short filter(short x, short filnr)
{
    short i = 0;
    long long y = 0;
    short coff, dat;
    fd[filnr][2] = fd[filnr][1];
    fd[filnr][1] = fd[filnr][0];
    fd[filnr][0] = x;
    for(i = 0; i < 5; i++)
    {
        coff = fc[filnr][i];
        dat = fd[filnr][i];
        y = (long long)y + (long long)coff*dat;
    }
    fd[filnr][4] = fd[filnr][3];
    fd[filnr][3] =(short)(y >> 12);
    return fd[filnr][3];
}
\end{lstlisting}
\begin{lstlisting}[caption={Function that keeps track of multiple filters.},language=C,label={apcode:mult_func_filter},tabsize=2]
short multifilter(short x)
{
    int i = 0;
    int inp = x;
    for(i = 0; i <3; i++)
    {
        inp = filter(inp,i);
    }
    return inp;
}
\end{lstlisting}
\begin{lstlisting}[caption={Calculate low frequency shelving filter coefficients.},language=C,label={apcode:calc_lo_filt},tabsize=2]
void calc_coeffs_lo_shelf( short * coeffs, long long w, short G)
{
    long long coef_a0 = 0, coef_b0 = 0, coef_b1 = 0, coef_a1 = 0;
    short bb0 = 0, bb1 = 0, aa0 = 0, aa1 = 0;
    short shifft = 12;
    if(G > 0)
    {
        G=dbtog[G];
        coef_a0 = (long long) 2*Fs+(long long)w;
        coef_a1 = (long long) -2*Fs+(long long)w;
        coef_b0 = (((long long) G*w)>>4) + (long long)2*Fs + (long long)w;
        coef_b1 = (((long long) G*w)>>4) - (long long)2*Fs + (long long)w;
    }
    if(G < 0)
    {
        G=dbtog[abs(G)];
        coef_b0 = (long long) 2*Fs+(long long)w;
        coef_b1 = (long long) -2*Fs+(long long)w;
        coef_a0 = (((long long) G*w)>>4) + (long long)2*Fs + (long long)w;
        coef_a1 = (((long long) G*w)>>4) - (long long)2*Fs + (long long)w;
    }
    if(G != 0)
    {
        bb0 =  (short)((coef_b0)/(coef_a0>>shifft));
        bb1 =  (short)(((coef_b1)/(coef_a0>>shifft)));
        aa1 =  -(short)(((coef_a1)/(coef_a0>>shifft)));
        aa0 = (short)((coef_a0)/(coef_a0>>shifft));
    }
    else// if gain = 0 then give direct coefficients
    {
        bb0 = 4096;
        bb1 = 0;
        aa1 = 0;
        aa0 = 4096;
    }
    coeffs[0] =  bb0;
    coeffs[1] =  bb1;
    coeffs[2] =  0;
    coeffs[3] =  aa1;
    coeffs[4] =  0;

    return;
}
\end{lstlisting}
\begin{lstlisting}[caption={Calculate high frequency shelving filter coefficients.},language=C,label={apcode:calc_hi_filt},tabsize=2]
void calc_coeffs_hi_shelf( short * coeffs, long long w, short G)
{
    long long coef_a0 = 0, coef_b0 = 0, coef_b1 = 0, coef_a1 = 0;
    short bb0 = 0, bb1 = 0, aa0 = 0, aa1 = 0;
    short shifft = 12;
    if(G > 0)
    {
        G=dbtog[G];
        coef_a0 = (long long)2*Fs+(long long)w;
        coef_a1 = -((long long)2*Fs-(long long)w);
        coef_b0 = (((long long)2*G*Fs)>>4)+(long long)2*Fs+(long long)w;
        coef_b1 = -((((long long)2*G*Fs)>>4)+(long long)2*Fs-(long long)w);
    }
    if(G < 0)
    {
        G=dbtog[abs(G)];
        coef_b0 = (long long)2*Fs+(long long)w;
        coef_b1 = -((long long)2*Fs-(long long)w);
        coef_a0 = (((long long)2*G*Fs)>>4)+(long long)2*Fs+(long long)w;
        coef_a1 = -((((long long)2*G*Fs)>>4)+(long long)2*Fs-(long long)w);
    }
    if(G != 0)
    {
        bb0 =  (short)((coef_b0)/(coef_a0>>shifft));
        bb1 =  (short)(((coef_b1)/(coef_a0>>shifft)));
        aa1 =  -(short)(((coef_a1)/(coef_a0>>shifft)));
        aa0 = (short)((coef_a0)/(coef_a0>>shifft));
    }
    else// if gain = 0 then give direct coefficients
    {
        bb0 = 4096;
        bb1 = 0;
        aa1 = 0;
        aa0 = 4096;
    }
    coeffs[0] =  bb0;
    coeffs[1] =  bb1;
    coeffs[2] =  0;
    coeffs[3] =  aa1;
    coeffs[4] =  0;

    return;
}
\end{lstlisting}
\begin{lstlisting}[caption={Calculate parametric band pass filter coefficients.},language=C,label={apcode:calc_bp_filt},tabsize=2]
void calc_coeffs_band( short * coeffs, unsigned short bw, long long w, short A)
{
    long long coef_a0 = 0, coef_b0 = 0, coef_b1 = 0, coef_a1 = 0;
    long long coef_b2 = 0, coef_a2 = 0;
    short bb0 = 0, bb1 = 0, bb2 = 0, aa0 = 0,aa1 = 0, aa2 = 0;
    short shifft = 6;
    unsigned long long ws = (unsigned long long) (w>>2)*(w>>2);
    ws = (ws <<4)/Fs;

    if(A > 0)
    {
        A = dbtoa[A];
        coef_a0 = ((unsigned long long)2*bw)+ftFs+ws;
        coef_a1 = -(etFs - (long long)2*ws);
        coef_a2 = -(((long long)2*bw)-ftFs-ws);
        coef_b0 = (((long long)A*bw)>>3)+ftFs+ws;
        coef_b1 = -(etFs - (long long) 2*ws);
        coef_b2 = -((((long long)A*bw)>>3)-ftFs-ws);

    }
    else if(A < 0)
    {
        A = dbtoa[abs(A)];
        coef_b0 = ((unsigned long long)2*bw)+ftFs+ws;
        coef_b1 = -(etFs - (long long)2*ws);
        coef_b2 = -(((long long)2*bw)-ftFs-ws);
        coef_a0 = (((long long)A*bw)>>3)+ftFs+ws;
        coef_a1 = -(etFs - (long long) 2*ws);
        coef_a2 = -((((long long)A*bw)>>3)-ftFs-ws);
    }
    if(A != 0)
    {
        bb0 =  (short)((coef_b0<<shifft)/(coef_a0>>shifft));
        bb1 =  (short)(((coef_b1<<shifft)/(coef_a0>>shifft)));
        bb2 =  (short)(((coef_b2<<shifft)/(coef_a0>>shifft)));
        aa1 =  -(short)(((coef_a1<<shifft)/(coef_a0>>shifft)));
        aa2 =  -(short)(((coef_a2<<shifft)/(coef_a0>>shifft)));
        aa0 =  (short)((coef_a0<<shifft)/(coef_a0>>shifft));
    }
    else // if gain = 0 then give direct coefficients
    {
        bb0 = 4096;
        bb1 = 0;
        bb2 = 0;
        aa0 = 4096;
        aa1 = 0;
        aa2 = 0;
    }
    coeffs[0] =  bb0;
    coeffs[1] =  bb1;
    coeffs[2] =  bb2;
    coeffs[3] =  aa1;
    coeffs[4] =  aa2;


    return;
}
\end{lstlisting}
\begin{lstlisting}[caption={Single delay implementation.},language=C,label={apcode:sdelay},tabsize=2]
short echo(short * rbufstart, unsigned short x, unsigned short delay, unsigned short gain)
{
    return (rbufstart[x] + ((long long) gain*rbufstart[(x+delay)%(DelayBuff)])>>12);
}
\end{lstlisting}


