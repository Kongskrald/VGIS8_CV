%!TEX root = ../../master.tex
\section{Flanger}
\label{sec:flanger_imp}
In this section the flanger effect designed and simulated in \autoref{sec:flanger_design} is implemented on the \gls{dsp} development board. The effect implemented is described from the block diagram in \autoref{fig:flanger_blockdiagram_design_imp}. 

\begin{figure}[htbp]
	\centering
	\includegraphics[scale=1.2]{figures/analysis/flanger_blockdiagram.pdf}
	\caption{Flanger block diagram.}
	\label{fig:flanger_blockdiagram_design_imp}
\end{figure}

\subsection{CORDIC Algorithm}
When implementing the variable delay in the flanger, an \gls{lfo} is needed for modulation purposes, and since this is made using a sinusoidal signal, a sine generator is needed. To implement a sine generator an algorithm named \gls{cordic} is used. In general \gls{cordic} is an algorithm for calculating hyperbolic and trigonometric functions. The algorithm solves in plane rotation from rectangular coordinates to polar coordinates, multiplications, division or the conversion between binary and a mixed radix system. \gls{cordic} can do this in one computing operation. In order to use \gls{cordic} as a signal generator the general equation for the CORDIC algorithm regarding micro rotations is seen in \autoref{eq:cordic}, where the new coordinates are rotated by $\theta$ for every iteration \citep{CORDIC}.

\begin{equation}
\begin{split}
	cos(t)=x'&= x \cdot cos\theta - y \cdot sin\theta \\
	sin(t)=y'&= y \cdot cos\theta + x \cdot sin\theta \\
	x &= x' \\
	y &= y'
\end{split}
\label{eq:cordic}	
\end{equation}

\startexplain
	\explain{$x'$ is the new $x$ value}{}
	\explain{$y'$ is the new $y$ value}{}
	\explain{$\theta$ is the angle of the step size around the unit circle}{}
	\explain{$x$ is the approximation for the cos function}{}
	\explain{$y$ is the approximation for the sin function}{}
\stopexplain

When the values of $x$ and $y$ change, this will change $x'$ and $y'$, and these two values are the value of the sine- and cosine function at that sample. The $x$- and $y$ values are initialized as the starting point coordinates of the rotation. 

\subsection{Software}
In the software implementation of the flanger effect, the main part is generating the variable delay. As stated above, this is done by implementing \gls{cordic} from \autoref{eq:cordic} in C. The C implementation can be seen in \autoref{code:flanger_imp_code}. The cosine part of the \gls{cordic} is used to make the variable delay. For low frequencies $cos \theta \approx 1$ therefore it is removed from the equation. This however gives a small error that can make the system unstable due to the value becoming larger than the allowed value in a variable. This causes overflow which changes the sign of the value. In order to avoid overflow a register called \texttt{SATD} is set. This saturates the results of addition in the accumulator. This causes the tip of the sinusoidal functions to flatten out giving a small error but making the system stable. 

In order to calculate the step size, theta, in fixed point, \autoref{eq:thetas_stepsize} is used. This results in \autoref{tab:thetas} for low frequencies. 

\begin{equation}\label{eq:thetas_stepsize}
thetas= sin\left(\frac{2\cdot \pi \cdot f}{Fs}\right)\cdot 2^{15}
\end{equation}
\startexplain
	\explain{f is the freuqency of the \gls{lfo}}{\si{\hertz}}
	\explain{Fs is the sample frequency}{\si{\hertz}}
	\explain{$2^{15}$ is the fixed point scaling }{}
\stopexplain


\begin{table}[H]
\centering
\caption{Table showing the correlation between thetas and the frequency.}
\label{tab:thetas}
\begin{tabular}{|l|l|}
\hline
thetas & Frequency {[}Hz{]} \\ \hline
1      & 0.21 \\ \hline
2      & 0.43 \\ \hline
3      & 0.64 \\ \hline
4      & 0.86 \\ \hline
5      & 1.07 \\ \hline
6      & 1.29 \\ \hline
7      & 1.50 \\ \hline
8      & 1.71 \\ \hline
9      & 1.93 \\ \hline
10     & 2.14 \\ \hline
\end{tabular}
\end{table}


\begin{lstlisting}[caption={Implementation of the flanger effect on the DSP in C.},language=C,label={code:flanger_imp_code},tabsize=2]
 dx = (long)(x - (long)((long)y*thetas>>15));
 dy = (long)(y + (long)((long)x*thetas>>15));
 x = (short)(dx);
 y = (short)(dy);
 delay_ms = ((long long)predelay<<15) + (long long)depth*y;
 outputs = delay(delay_buff, i, delay_ms);
\end{lstlisting}


The \gls{cordic} calculates the value of both the sine and cosine, and the cosine is then multiplied with a fixed delay called depth, which in this case is chosen to 31 samples, which is approximately \SI{0.7}{\milli\second}. This is one of the parameters, that can be varied according to how big a delay is wanted. There is also a predelay that dictates where the sine is oscillating around. When multiplying the value of the cosine with the fixed delay and adding the predelay, the delay will vary from \SI{-0.7}{\milli\second} to \SI{0.7}{\milli\second} or -31 to 31 samples around the predelay. This delay is then used in the function from the echo effect in \autoref{sec:echo_imp}. The different values are type casted in order to make sure, that the \gls{dsp} multiplies the number correctly according size.

